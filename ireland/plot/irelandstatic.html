<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="https://cdn.leafletjs.com/leaflet-0.7/leaflet.css" />
    <script src="https://d3js.org/d3.v3.min.js" type="text/javascript"></script>
    <script src="https://cdn.leafletjs.com/leaflet-0.7/leaflet.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox.js/v2.2.1/mapbox.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox.js/v1.6.3/mapbox.css' rel='stylesheet' />
    <style>
    html,
    body {
        height: 100%;
        width: 100%;
    }
    body {
        margin: 0;
    }
    #map {
        width: 100%;
        height: 100%;
    }
    svg {
        position: relative;
    }
    path {
        fill: black;
        stroke-width: 2px;
        stroke: red;
        stroke-opacity: 1;
    }
    .travelMarker {
        fill: gray;
        opacity: 0.55;
    }
    .waypoints {
        fill: black;
        opacity: 0;
    }
.drinks {
    stroke: black;
    fill: red;
}
.lineConnect {
    fill: none;
    stroke: black;
    opacity: 1;
}
.locnames {
    fill: black;
    font-size-adjust: 0.58;
    font-size: 6px;
}
    </style>

</head>

<body>

    <div id="demo"></div>
    <div class="infobox" style="visibility: hidden; height: 20px; vertical-align: bottom;">
	    <h3 class="name">pub name</h3></div>
    <div id="map"></div>
    <script type="text/javascript">
    L.mapbox.accessToken = 'pk.eyJ1IjoibmVhbC1vLXIiLCJhIjoiY2ppdzc1emR5MnM5bDNwbXBnMGdwa3prYyJ9.-TszO3tBXF5EFRaKsSe6tQ';
    var map = L.mapbox.map('map', 'mapbox.streets', {
    accessToken: 'pk.eyJ1IjoibmVhbC1vLXIiLCJhIjoiY2ppdzc1emR5MnM5bDNwbXBnMGdwa3prYyJ9.-TszO3tBXF5EFRaKsSe6tQ'}).setView([53.427, -7.942], 7);



    // we will be appending the SVG to the Leaflet map pane
    // g (group) element will be inside the svg 
    var svg = d3.select(map.getPanes().overlayPane).append("svg");

    // if you don't include the leaflet-zoom-hide when a 
    // user zooms in or out you will still see the phantom
    // original SVG 
    var g = svg.append("g").attr("class", "leaflet-zoom-hide");


    //read in the GeoJSON. This function is asynchronous so
    // anything that needs the json file should be within
    d3.json("ireland.json", function(collection) {

        // this is not needed right now, but for future we may need
        // to implement some filtering. This uses the d3 filter function
        // featuresdata is an array of point objects

        var featuresdata = collection.features.filter(function(d) {
            return d.properties.id == "route1"
        })

        //stream transform. transforms geometry before passing it to
        // listener. Can be used in conjunction with d3.geo.path
        // to implement the transform. 

        var transform = d3.geo.transform({
            point: projectPoint
        });

        //d3.geo.path translates GeoJSON to SVG path codes.
        //essentially a path generator. In this case it's
        // a path generator referencing our custom "projection"
        // which is the Leaflet method latLngToLayerPoint inside
        // our function called projectPoint
        var d3path = d3.geo.path().projection(transform);


        // Here we're creating a FUNCTION to generate a line
        // from input points. Since input points will be in 
        // Lat/Long they need to be converted to map units
        // with applyLatLngToLayer
        var toLine = d3.svg.line()
            .interpolate("linear")
            .x(function(d) {
                return applyLatLngToLayer(d).x
            })
            .y(function(d) {
                return applyLatLngToLayer(d).y
            });


        // From now on we are essentially appending our features to the
        // group element. We're adding a class with the line name
        // and we're making them invisible

        // Here we will make the points into a single
        // line/path. Note that we surround the featuresdata
        // with [] to tell d3 to treat all the points as a
        // single line. For now these are basically points
        // but below we set the "d" attribute using the 
        // line creator function from above.
        var linePath = g.selectAll(".lineConnect")
            .data([featuresdata])
            .enter()
            .append("path")
            .attr("class", "lineConnect");

        var ptFeatures = g.selectAll(".drinks")
            .data(featuresdata)
            .enter()
            .append("circle", ".drinks")
            .attr("r", 2)
            .style("fill", "red")
	    .style("opacity", "1")
	    .on('mouseover', function(d, i) {
		// make the mouseover'd element
		// bigger and red
		d3.select(".infobox .name").text("None");
		d3.select(".infobox").style('visibility', 'visible');
		d3.select(this)
			.transition()
			.duration(100)
			.attr('r', 20)
			.attr('fill', "red");
		})
		.on('mouseout', function(d, i) {
		// return the mouseover'd element
		// to being smaller and black
		d3.select(".infobox").style('visibility', 'hidden');
		d3.select(this)
			.transition()
			.duration(100)
			.attr('r', 2)
			.attr('fill', "red");
		})
		    
	var text = g.selectAll("text")
            .data(featuresdata)
            .enter()
            .append("text")
            .attr("class", "locnames")
            .attr("y", function(d) {
                return -10
            })
//.text(function(d) {
//return "None"})


        // when the user zooms in or out you need to reset
        // the view
        map.on("viewreset", reset);

        // this puts stuff on the map! 
        reset();

        // Reposition the SVG to cover the features.
        function reset() {
            var bounds = d3path.bounds(collection),
                topLeft = bounds[0],
                bottomRight = bounds[1];


            // here you're setting some styles, width, heigh etc
            // to the SVG. Note that we're adding a little height and
            // width because otherwise the bounding box would perfectly
            // cover our features BUT... since you might be using a big
            // circle to represent a 1 dimensional point, the circle
            // might get cut off.

            // for the points we need to convert from latlong
            // to map units
            ptFeatures.attr("transform",
                function(d) {
                    return "translate(" +
                        applyLatLngToLayer(d).x + "," +
                        applyLatLngToLayer(d).y + ")";
                });
	
	    text.attr("transform",
                function(d) {
                    return "translate(" +
                        applyLatLngToLayer(d).x + "," +
                        applyLatLngToLayer(d).y + ")";
                });


            // Setting the size and location of the overall SVG container
            svg.attr("width", bottomRight[0] - topLeft[0] + 120)
                .attr("height", bottomRight[1] - topLeft[1] + 120)
                .style("left", topLeft[0] - 50 + "px")
                .style("top", topLeft[1] - 50 + "px");


            // linePath.attr("d", d3path);
            linePath.attr("d", toLine)
            // ptPath.attr("d", d3path);
            g.attr("transform", "translate(" + (-topLeft[0] + 50) + "," + (-topLeft[1] + 50) + ")");

        } // end reset

        // Use Leaflet to implement a D3 geometric transformation.
        // the latLngToLayerPoint is a Leaflet conversion method:
        //Returns the map layer point that corresponds to the given geographical
        // coordinates (useful for placing overlays on the map).
        function projectPoint(x, y) {
            var point = map.latLngToLayerPoint(new L.LatLng(y, x));
            this.stream.point(point.x, point.y);
        } //end projectPoint
    });


    // similar to projectPoint this function converts lat/long to
    // svg coordinates except that it accepts a point from our 
    // GeoJSON

    function applyLatLngToLayer(d) {
        var y = d.geometry.coordinates[1]
        var x = d.geometry.coordinates[0]
        return map.latLngToLayerPoint(new L.LatLng(y, x))


    }
    </script>
</body>

</html>
